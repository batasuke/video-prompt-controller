<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Video Prompt Controller - Prompt Wizard</title>
  <style>
    :root { --bg:#0b0f17; --card:#121a26; --text:#e7eefc; --muted:#a7b4cc; --accent:#7aa2ff; --bad:#ff6b6b; --good:#4ade80; }
    * { box-sizing:border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif; background:var(--bg); color:var(--text); }
    .wrap { max-width: 980px; margin: 0 auto; padding: 18px; }
    header { display:flex; gap:12px; align-items:baseline; flex-wrap:wrap; margin-bottom: 14px; }
    h1 { font-size: 18px; margin:0; }
    .sub { color:var(--muted); font-size: 12px; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 14px; }
    @media (min-width: 900px) { .grid { grid-template-columns: 360px 1fr; } }

    .card { background:var(--card); border:1px solid rgba(255,255,255,.08); border-radius: 16px; padding: 14px; box-shadow: 0 8px 24px rgba(0,0,0,.25); }
    .steps { display:flex; gap:8px; flex-wrap:wrap; }
    .pill { padding: 8px 10px; border-radius: 999px; border:1px solid rgba(255,255,255,.12); color:var(--muted); font-size: 12px; }
    .pill.active { border-color: rgba(122,162,255,.7); color: var(--text); }
    .pill.done { border-color: rgba(74,222,128,.6); color: var(--text); }
    .row { display:grid; grid-template-columns: 1fr; gap: 10px; margin-top: 10px; }
    @media (min-width: 520px) { .row.two { grid-template-columns: 1fr 1fr; } }
    label { display:block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    input, select, textarea {
      width:100%; padding: 10px 12px; border-radius: 12px;
      background: rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.12);
      color: var(--text); outline:none;
    }
    textarea { min-height: 110px; resize: vertical; }
    input:focus, select:focus, textarea:focus { border-color: rgba(122,162,255,.7); }
    .help { font-size: 12px; color:var(--muted); line-height: 1.5; }
    .hr { height:1px; background: rgba(255,255,255,.10); margin: 12px 0; }
    .btns { display:flex; gap:10px; flex-wrap:wrap; margin-top: 12px; }
    button {
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
    }
    button.primary { background: rgba(122,162,255,.18); border-color: rgba(122,162,255,.55); }
    button.danger { background: rgba(255,107,107,.14); border-color: rgba(255,107,107,.45); }
    button:disabled { opacity: .45; cursor: not-allowed; }
    .msg { padding: 10px 12px; border-radius: 12px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.04); font-size: 12px; }
    .msg.bad { border-color: rgba(255,107,107,.45); background: rgba(255,107,107,.10); }
    .msg.good { border-color: rgba(74,222,128,.45); background: rgba(74,222,128,.10); }
    pre {
      margin:0; padding: 12px; border-radius: 12px;
      background: rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.10);
      overflow:auto; font-size: 12px; line-height: 1.45;
    }
    .tiny { font-size: 11px; color: var(--muted); margin-top: 8px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Grok 動画生成プロンプト ウィザード（最大3シーン・6秒）</h1>
      <div class="sub">PC / スマホ対応・最小入力でJSON生成 → コピーして貼るだけ</div>
    </header>

    <div class="grid">
      <div class="card">
        <div class="steps" id="stepPills"></div>
        <div class="hr"></div>
        <div class="help">
          ・必須：mode / aspect / quality / 全体スタイル（プリセット or カスタム） / シーン1（必須）<br>
          ・任意：シーン2・シーン3（空なら未使用扱い）<br>
          ・制約：使用中シーンの秒数合計は<strong>6.0秒以下</strong><br>
          ・秒数：スマホ入力対策で<strong>0.5秒刻みの選択式</strong>
        </div>
        <div class="btns">
          <button id="btnPrev">← 戻る</button>
          <button class="primary" id="btnNext">次へ →</button>
          <button class="danger" id="btnReset">リセット</button>
        </div>
        <div class="tiny" id="saveNote">入力はこの端末のブラウザに自動保存されます（localStorage）。</div>
      </div>

      <div class="card" id="content"></div>
    </div>
  </div>

  <script>
    const STORAGE_KEY = "vpc_prompt_wizard_v3";

    const STYLE_PRESETS = [
      { key: "anime_bright", name: "アニメ調（明るめ）", value: "anime style, soft lighting, vibrant colors" },
      { key: "anime_serious", name: "アニメ調（シリアス）", value: "anime style, dark tone, dramatic shadows" },
      { key: "photo_cinema", name: "実写調（映画風）", value: "photorealistic, cinematic lighting, shallow depth of field" },
      { key: "photo_cm", name: "実写調（CM風）", value: "photorealistic, clean lighting, commercial style" },
      { key: "illustration", name: "イラスト調", value: "digital illustration, painterly style" },
      { key: "custom", name: "カスタム（自分で入力）", value: "" },
    ];
    const presetMap = Object.fromEntries(STYLE_PRESETS.map(p => [p.key, p.value]));

    const SECOND_OPTIONS = (() => {
      const arr = [];
      for (let s = 0.5; s <= 6.0 + 1e-9; s += 0.5) arr.push(Number(s.toFixed(1)));
      return arr;
    })();

    const stateDefault = {
      step: 0,
      basic: { mode: "Normal", aspect_ratio: "9:16", quality: "High" },
      style: { presetKey: "anime_bright", customText: "" },
      scenes: [
        { description: "", camera: "", seconds: 2.0 }, // scene1: required
        { description: "", camera: "", seconds: 0.0 }, // scene2: optional (0 = unused)
        { description: "", camera: "", seconds: 0.0 }, // scene3: optional (0 = unused)
      ],
    };

    const steps = [
      { title: "1 基本" },
      { title: "2 スタイル" },
      { title: "3 シーン" },
      { title: "4 生成" },
    ];

    let state = loadState();
    const $ = (sel) => document.querySelector(sel);
    function clamp(n, min, max) { return Math.min(max, Math.max(min, n)); }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return structuredClone(stateDefault);
        const parsed = JSON.parse(raw);
        return mergeSafe(structuredClone(stateDefault), parsed);
      } catch {
        return structuredClone(stateDefault);
      }
    }

    function saveState() { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

    function mergeSafe(base, incoming) {
      if (incoming && typeof incoming === "object") {
        if (typeof incoming.step === "number") base.step = clamp(incoming.step, 0, steps.length - 1);

        if (incoming.basic && typeof incoming.basic === "object") {
          base.basic.mode = incoming.basic.mode ?? base.basic.mode;
          base.basic.aspect_ratio = incoming.basic.aspect_ratio ?? base.basic.aspect_ratio;
          base.basic.quality = incoming.basic.quality ?? base.basic.quality;
        }

        if (incoming.style && typeof incoming.style === "object") {
          const pk = incoming.style.presetKey ?? base.style.presetKey;
          base.style.presetKey = presetMap[pk] !== undefined ? pk : base.style.presetKey;
          base.style.customText = incoming.style.customText ?? base.style.customText;
        }

        if (Array.isArray(incoming.scenes) && incoming.scenes.length === 3) {
          base.scenes = incoming.scenes.map((s, i) => ({
            description: (s?.description ?? base.scenes[i].description),
            camera: (s?.camera ?? base.scenes[i].camera),
            seconds: Number.isFinite(Number(s?.seconds)) ? Number(s.seconds) : base.scenes[i].seconds,
          }));
        }
      }
      // guard: scene1 must have a positive default
      if (!(Number(base.scenes[0].seconds) > 0)) base.scenes[0].seconds = 2.0;
      // optional scenes: if invalid, set 0 (unused)
      for (let i = 1; i <= 2; i++) {
        const sec = Number(base.scenes[i].seconds);
        if (!Number.isFinite(sec) || sec < 0) base.scenes[i].seconds = 0.0;
      }
      return base;
    }

    function getFinalVisual() {
      const presetKey = state.style.presetKey;
      const preset = (presetMap[presetKey] ?? "").trim();
      const custom = (state.style.customText ?? "").trim();

      if (presetKey === "custom") return custom;
      if (!custom) return preset;
      if (custom.startsWith(",") || custom.startsWith(";")) return preset + " " + custom;
      return preset + ", " + custom;
    }

    function isSceneUsed(i) {
      if (i === 0) return true; // scene1 always used
      const sc = state.scenes[i];
      const hasText = (sc.description || "").trim() || (sc.camera || "").trim();
      const sec = Number(sc.seconds) || 0;
      return Boolean(hasText) || sec > 0;
    }

    function usedScenes() {
      const out = [];
      for (let i = 0; i < 3; i++) {
        if (!isSceneUsed(i)) continue;
        out.push({ i, sc: state.scenes[i] });
      }
      return out;
    }

    function sumUsedSeconds() {
      return usedScenes().reduce((a, x) => a + (Number(x.sc.seconds) || 0), 0);
    }

    function render() {
      renderPills();
      renderStep();
      renderNav();
      saveState();
    }

    function renderPills() {
      const el = $("#stepPills");
      el.innerHTML = "";
      steps.forEach((s, i) => {
        const pill = document.createElement("div");
        pill.className = "pill" + (i === state.step ? " active" : "") + (i < state.step ? " done" : "");
        pill.textContent = s.title;
        pill.style.cursor = "pointer";
        pill.onclick = () => { state.step = i; render(); };
        el.appendChild(pill);
      });
    }

    function renderNav() {
      $("#btnPrev").disabled = state.step === 0;
      $("#btnNext").textContent = state.step === steps.length - 1 ? "完了" : "次へ →";
      const v = validateStep(state.step);
      $("#btnNext").disabled = !v.ok && state.step !== steps.length - 1;
    }

    function validateStep(stepIdx) {
      if (stepIdx === 0) return { ok: true };

      if (stepIdx === 1) {
        const visual = getFinalVisual();
        if (!visual) return { ok: false, message: "全体スタイルが空やで。プリセットを選ぶか、カスタムを入力してや。", kind: "bad" };
        return { ok: true, message: "OKや。", kind: "good" };
      }

      if (stepIdx === 2) {
        const sum = sumUsedSeconds();
        if (sum > 6.0 + 1e-9) return { ok: false, message: `秒数合計が6秒を超えとる（今 ${sum.toFixed(1)} 秒）。6秒以内にしてや。`, kind:"bad" };

        // Scene1 required
        const s1 = state.scenes[0];
        if (!s1.description.trim()) return { ok:false, message:"シーン1の説明（description）が空やで。", kind:"bad" };
        if (!s1.camera.trim()) return { ok:false, message:"シーン1のカメラ（camera）が空やで。", kind:"bad" };
        if (!(Number(s1.seconds) > 0)) return { ok:false, message:"シーン1の秒数が不正やで。", kind:"bad" };

        // Scene2/3 optional: if any text is entered or seconds > 0, require all fields + seconds > 0
        for (let i = 1; i <= 2; i++) {
          const sc = state.scenes[i];
          const hasDesc = sc.description.trim().length > 0;
          const hasCam = sc.camera.trim().length > 0;
          const sec = Number(sc.seconds) || 0;

          const triggered = hasDesc || hasCam || sec > 0;
          if (!triggered) continue; // fully empty -> allowed

          if (!(sec > 0)) return { ok:false, message:`シーン${i+1}は入力があるのに秒数が未設定（未使用）になっとるで。秒数を選んでや。`, kind:"bad" };
          if (!hasDesc) return { ok:false, message:`シーン${i+1}の説明（description）が空やで。`, kind:"bad" };
          if (!hasCam) return { ok:false, message:`シーン${i+1}のカメラ（camera）が空やで。`, kind:"bad" };
        }

        const usedCount = usedScenes().length;
        return { ok:true, message:`OKや。使用シーン ${usedCount} / 3、合計 ${sum.toFixed(1)} 秒（6秒以内）。`, kind:"good" };
      }

      if (stepIdx === 3) return { ok:true };
      return { ok:true };
    }

    function renderSecondsSelect(id, current, allowUnused) {
      const opts = [];
      if (allowUnused) opts.push(`<option value="0">未使用</option>`);
      for (const s of SECOND_OPTIONS) {
        opts.push(`<option value="${s}">${s.toFixed(1).replace(/\.0$/, "")} 秒</option>`);
      }
      return `<select id="${id}">${opts.join("")}</select>`;
    }

    function renderStep() {
      const c = $("#content");
      const step = state.step;

      if (step === 0) {
        c.innerHTML = `
          <h2 style="margin:0 0 6px;font-size:16px;">基本設定</h2>
          <div class="row two">
            <div>
              <label>モード (mode)</label>
              <select id="mode">
                <option>Normal</option>
                <option>Fun</option>
                <option>Custom</option>
                <option>Spicy</option>
              </select>
            </div>
            <div>
              <label>アスペクト比 (aspect_ratio)</label>
              <select id="aspect">
                <option>9:16</option>
                <option>16:9</option>
                <option>1:1</option>
              </select>
            </div>
          </div>
          <div class="row two">
            <div>
              <label>品質 (quality)</label>
              <select id="quality">
                <option>High</option>
                <option>Medium</option>
                <option>Low</option>
              </select>
            </div>
            <div>
              <label>動画長 (duration)</label>
              <input value="6 seconds（固定）" disabled />
            </div>
          </div>
          <div class="hr"></div>
          <div class="help">次で全体スタイル（プリセット/カスタム）を入れるで。</div>
        `;
        $("#mode").value = state.basic.mode;
        $("#aspect").value = state.basic.aspect_ratio;
        $("#quality").value = state.basic.quality;

        $("#mode").onchange = (e) => { state.basic.mode = e.target.value; renderNav(); saveState(); };
        $("#aspect").onchange = (e) => { state.basic.aspect_ratio = e.target.value; renderNav(); saveState(); };
        $("#quality").onchange = (e) => { state.basic.quality = e.target.value; renderNav(); saveState(); };
        return;
      }

      if (step === 1) {
        const v = validateStep(1);
        const finalVisual = getFinalVisual();
        c.innerHTML = `
          <h2 style="margin:0 0 6px;font-size:16px;">全体スタイル（プリセット選択 + 微調整）</h2>

          <div class="row">
            <div>
              <label>プリセット</label>
              <select id="preset"></select>
              <div class="tiny">※「カスタム」を選ぶと下の入力欄が必須になるで。</div>
            </div>
          </div>

          <div class="row">
            <div>
              <label id="customLabel">追加/微調整（任意）</label>
              <textarea id="custom" placeholder="例: cinematic lighting, shallow depth of field"></textarea>
              <div class="tiny">プリセット + ここ（追記）が最終の visual になるで。</div>
            </div>
          </div>

          <div class="hr"></div>
          <div class="help">最終 visual（プレビュー）</div>
          <pre class="mono" id="preview"></pre>

          <div class="hr"></div>
          ${v.ok ? `<div class="msg good">OKや。次へ進めるで。</div>` : `<div class="msg bad">${escapeHtml(v.message)}</div>`}
        `;

        const presetSel = $("#preset");
        presetSel.innerHTML = STYLE_PRESETS.map(p => `<option value="${p.key}">${escapeHtml(p.name)}</option>`).join("");
        presetSel.value = state.style.presetKey;

        const customTa = $("#custom");
        customTa.value = state.style.customText ?? "";

        function refreshStyleUI() {
          const pk = presetSel.value;
          state.style.presetKey = pk;

          const isCustom = pk === "custom";
          $("#customLabel").textContent = isCustom ? "カスタム入力（必須）" : "追加/微調整（任意）";
          customTa.placeholder = isCustom ? "例: anime style, soft lighting, vibrant colors" : "例: cinematic lighting, shallow depth of field";

          $("#preview").textContent = getFinalVisual() || "（空）";
          renderNav();
          saveState();
        }

        presetSel.onchange = refreshStyleUI;
        customTa.oninput = (e) => { state.style.customText = e.target.value; refreshStyleUI(); };

        $("#preview").textContent = finalVisual || "（空）";
        refreshStyleUI();
        return;
      }

      if (step === 2) {
        const v = validateStep(2);
        const sum = sumUsedSeconds();
        const usedCount = usedScenes().length;

        c.innerHTML = `
          <h2 style="margin:0 0 6px;font-size:16px;">シーン（シーン1必須 / シーン2・3は任意）</h2>
          <div class="help">
            合計 <strong>6.0秒以内</strong>。今の合計：<strong>${sum.toFixed(1)}秒</strong>（使用シーン ${usedCount} / 3）<br>
            ※ 秒数は <strong>0.5秒刻み</strong>で選べるで（スマホ対策）
          </div>

          <div class="hr"></div>
          <h3 style="margin:0 0 8px;font-size:14px;">シーン 1（必須）</h3>
          <div class="row">
            <div>
              <label>説明 (description)</label>
              <textarea id="desc0" placeholder="例: close-up of a chocolate bar melting..."></textarea>
            </div>
          </div>
          <div class="row two">
            <div>
              <label>カメラ (camera)</label>
              <input id="cam0" placeholder="例: close-up, slow pan, handheld" />
            </div>
            <div>
              <label>秒数 (seconds)</label>
              ${renderSecondsSelect("sec0", state.scenes[0].seconds, false)}
            </div>
          </div>

          <div class="hr"></div>
          <h3 style="margin:0 0 8px;font-size:14px;">シーン 2（任意 / 空なら未使用）</h3>
          <div class="row">
            <div>
              <label>説明 (description)</label>
              <textarea id="desc1" placeholder="未入力なら未使用扱い"></textarea>
            </div>
          </div>
          <div class="row two">
            <div>
              <label>カメラ (camera)</label>
              <input id="cam1" placeholder="未入力なら未使用扱い" />
            </div>
            <div>
              <label>秒数 (seconds)</label>
              ${renderSecondsSelect("sec1", state.scenes[1].seconds, true)}
            </div>
          </div>

          <div class="hr"></div>
          <h3 style="margin:0 0 8px;font-size:14px;">シーン 3（任意 / 空なら未使用）</h3>
          <div class="row">
            <div>
              <label>説明 (description)</label>
              <textarea id="desc2" placeholder="未入力なら未使用扱い"></textarea>
            </div>
          </div>
          <div class="row two">
            <div>
              <label>カメラ (camera)</label>
              <input id="cam2" placeholder="未入力なら未使用扱い" />
            </div>
            <div>
              <label>秒数 (seconds)</label>
              ${renderSecondsSelect("sec2", state.scenes[2].seconds, true)}
            </div>
          </div>

          <div class="hr"></div>
          ${v.message ? `<div class="msg ${v.kind === "good" ? "good" : "bad"}">${escapeHtml(v.message)}</div>` : ""}
          <div class="tiny">
            ※ シーン2/3は「未使用」にしておけば空のままでも次に進めるで。<br>
            ※ 逆に、説明/カメラを入れたなら秒数も選んでや（整合性チェックするで）。
          </div>
        `;

        // bind fields
        for (let i = 0; i < 3; i++) {
          $("#desc"+i).value = state.scenes[i].description;
          $("#cam"+i).value = state.scenes[i].camera;

          $("#desc"+i).oninput = (e) => { state.scenes[i].description = e.target.value; renderNav(); saveState(); };
          $("#cam"+i).oninput  = (e) => { state.scenes[i].camera = e.target.value; renderNav(); saveState(); };

          const secSel = $("#sec"+i);
          secSel.value = String(Number(state.scenes[i].seconds) || 0);
          secSel.onchange = (e) => {
            const val = Number(e.target.value);
            state.scenes[i].seconds = Number.isFinite(val) ? val : (i === 0 ? 2.0 : 0.0);
            render();
          };
        }
        return;
      }

      if (step === 3) {
        const json = buildPromptJson();
        c.innerHTML = `
          <h2 style="margin:0 0 6px;font-size:16px;">生成（JSON）</h2>
          <div class="help">下のJSONをコピーして、そのままGrokに貼り付けたらええ。</div>
          <div class="hr"></div>
          <div class="btns">
            <button class="primary" id="btnCopy">JSONをコピー</button>
            <button id="btnDownload">JSONを保存（.json）</button>
          </div>
          <div class="hr"></div>
          <pre id="jsonOut"></pre>
          <div class="tiny">※ 未使用シーン（空のシーン2/3）はJSONに出さへん。</div>
          <div id="copyMsg" style="margin-top:10px;"></div>
        `;

        const pretty = JSON.stringify(json, null, 2);
        $("#jsonOut").textContent = pretty;

        $("#btnCopy").onclick = async () => {
          try {
            await navigator.clipboard.writeText(pretty);
            $("#copyMsg").innerHTML = `<div class="msg good">コピー完了や。Grokに貼り付けて生成してや。</div>`;
          } catch {
            fallbackCopy(pretty);
            $("#copyMsg").innerHTML = `<div class="msg good">コピー（フォールバック）完了や。Grokに貼り付けて生成してや。</div>`;
          }
        };

        $("#btnDownload").onclick = () => {
          const blob = new Blob([pretty], { type: "application/json" });
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = "grok_video_prompt.json";
          a.click();
          URL.revokeObjectURL(a.href);
        };
        return;
      }
    }

    function fmtSeconds(sec) {
      const s = Number(sec).toFixed(1).replace(/\.0$/, "");
      return `${s} seconds`;
    }

    function buildPromptJson() {
      const visual = getFinalVisual();
      const scenesOut = usedScenes().map(({ i, sc }) => ({
        description: sc.description.trim(),
        camera: sc.camera.trim(),
        duration: fmtSeconds(sc.seconds)
      }));

      return {
        video_script: {
          scenes: scenesOut,
          overall_style: { visual }
        },
        mode: state.basic.mode,
        aspect_ratio: state.basic.aspect_ratio,
        quality: state.basic.quality,
        duration: "6 seconds"
      };
    }

    function fallbackCopy(text) {
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      document.body.removeChild(ta);
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    $("#btnPrev").onclick = () => {
      state.step = clamp(state.step - 1, 0, steps.length - 1);
      render();
    };

    $("#btnNext").onclick = () => {
      if (state.step < steps.length - 1) {
        const v = validateStep(state.step);
        if (!v.ok) return;
        state.step = clamp(state.step + 1, 0, steps.length - 1);
        render();
      }
    };

    $("#btnReset").onclick = () => {
      state = structuredClone(stateDefault);
      localStorage.removeItem(STORAGE_KEY);
      render();
    };

    render();
  </script>
</body>
</html>
